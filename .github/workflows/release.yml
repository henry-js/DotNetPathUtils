name: Release and Publish

on:
  push:
    branches:
      - main
  workflow_dispatch:

# Add this permissions block
permissions:
  contents: write

jobs:
  # Job 1: (Unchanged)
  version:
    name: Determine Version & Create Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.minver.outputs.version }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json
      - name: Restore .NET local tools
        run: dotnet tool restore
      - name: Get version from MinVer
        id: minver
        run: |
          echo "version=$(dotnet minver --tag-prefix v --minimum-major-minor 1.0 -v e)" >> $GITHUB_OUTPUT
      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.minver.outputs.version }}
          release_name: Release v${{ steps.minver.outputs.version }}
          body: "Automated release for version ${{ steps.minver.outputs.version }}."
          draft: false
          prerelease: false

  # Job 2: (MODIFIED)
  build:
    name: Build, Test & Package
    needs: version
    runs-on: ubuntu-latest
    # Define outputs that this job will produce
    outputs:
      is_library: ${{ steps.package.outputs.is_library }}
      is_application: ${{ steps.package.outputs.is_application }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json
      - name: Setup Taskfile
        uses: arduino/setup-task@v2
      - name: Create .env file
        run: |
          cp public.env .env
          echo "NUGET_API_KEY=DUMMY_KEY" >> .env
      
      - name: Run Tests
        # We specify the sub-taskfile directly to be explicit
        run: task test -t ./.build/dotnet/Taskfile.yml

      - name: Package based on project type
        id: package # Give this step an ID to reference its outputs
        run: |
          # Source the variables from the public.env file
          source public.env

          # Check if PROJECT_TO_PACK is set and run the corresponding task
          if [[ -n "$PROJECT_TO_PACK" ]]; then
            echo "Project is a library. Packing NuGet package..."
            task pack:nuget
            echo "is_library=true" >> $GITHUB_OUTPUT
          else
            echo "is_library=false" >> $GITHUB_OUTPUT
          fi

          # Check if PROJECT_TO_PUBLISH is set and run the corresponding task
          if [[ -n "$PROJECT_TO_PUBLISH" ]]; then
            echo "Project is an application. Publishing files for Velopack..."
            task publish-app -v -- --RID win-x64 # Pass RID to the task
            echo "is_application=true" >> $GITHUB_OUTPUT
          else
            echo "is_application=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/

  # Job 3: (MODIFIED)
  publish-nuget:
    name: Publish NuGet Package
    needs: [version, build]
    runs-on: ubuntu-latest
    # The 'if' condition is now clean and refers to the build job's output
    if: success() && needs.build.outputs.is_library == 'true'
    steps:
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist
      - name: Setup Taskfile
        uses: arduino/setup-task@v2
      - name: Create .env file with Secret
        run: |
          # We don't need the full public.env, just the required secret
          echo "NUGET_API_KEY=${{ secrets.NUGET_API_KEY }}" >> .env
          # Source the public env to get the source URL and project path
          source public.env
          echo "NUGET_SOURCE_URL=$NUGET_SOURCE_URL" >> .env
          echo "PROJECT_TO_PACK=$PROJECT_TO_PACK" >> .env

      - name: Push NuGet Package
        run: task dotnet:push-nuget

  # Job 4: (MODIFIED)
  publish-velopack:
    name: Publish Velopack Release
    needs: [version, build]
    runs-on: windows-latest
    # The 'if' condition is now clean and refers to the build job's output
    if: success() && needs.build.outputs.is_application == 'true'
    steps:
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist

      - name: Setup Taskfile
        uses: arduino/setup-task@v2

      - name: Create .env file
        run: copy public.env .env
        shell: pwsh

      - name: Install Velopack CLI
        run: dotnet tool install -g vpk

      - name: Create Velopack Package
        run: task pack:velopack
        env:
          APP_VERSION: ${{ needs.version.outputs.version }}
          RID: win-x64
        shell: pwsh

      - name: Upload Release Assets with GitHub CLI
        # This single step uses the official gh CLI to upload all release assets.
        # It correctly handles wildcards.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload v${{ needs.version.outputs.version }} ./dist/releases/*
        shell: pwsh